##阅读的资料：
###**8086**
segment:offset
16位:16位

最终地址：segment*0x10+offset

为了让16位可以寻址20位地址总线。
但是最多的情况下还多出一位21位。最高位清零：
0xffff*0x10+0xffff=0x10ffef=0x0ffef
参见:
[寻访x86处理器“实模式”和“保护模式”的前世今生 ](http://blog.chinaunix.net/uid-23069658-id-3569341.html?page=2)

##**80286**
为了可以支持16M内存:
提供了解除第21位地址的方式：
键盘控制器输入端口的第2位是低位，则物理地址的第21位被清零；否则第21位可以正常使用。
可以用I/O指令控制端口0x64和0x60上的键盘控制器，使其输出端口的第2位为高位，来使第21位地址正常工作：
参见xv6-(8436行)
```
8420 # Physical address line A20 is tied to zero so that the first PCs
8421 # with 2 MB would run software that assumed 1 MB. Undo that.
8422 seta20.1:
8423 inb $0x64,%al # Wait for not busy
8424 testb $0x2,%al
8425 jnz seta20.1
8426
8427 movb $0xd1,%al # 0xd1 ?> port 0x64
8428 outb %al,$0x64
8429
8430 seta20.2:
8431 inb $0x64,%al # Wait for not busy
8432 testb $0x2,%al
8433 jnz seta20.2
8434
8435 movb $0xdf,%al # 0xdf ?> port 0x60
8436 outb %al,$0x60
```
打开A20地址线的三种方法：
[打开A20地址线的方法](http://blog.163.com/yangfan876@126/blog/static/80612456201381635550161/)

##**80386**保护模式来袭

>在保护模式下改变段寄存器的功能，使其从一个单纯的段基址变成指向一个“段描述符”的指针。因此，当一个访存指令发出一个内存地址时， CPU按照下面过程实现从指令中的32位逻辑地址到32位线性地址，再到物理地址的转换：
1. 首先根据指令的性质来确定该使用哪一个段寄存器，例如操作指令中的地址在代码段CS里，而数据指令中的地址在数据段DS里。这一点与实地址模式相同。
2. 根据段寄存器里的内容，找到相应的“段描述符”结构。
3. 然后，从“段描述符”里得到的才是段基址。
4. 将指令中的地址作为偏移量，然后和段描述符结构中规定的段长度进行比较，看齐是否越界。
5. 根据指令的性质和段描述符中的访问权限来确定当前指令操作是否越权。
6. 最后才将指令中的地址作为偏移量，与段基址相加得到线性地址，或者叫虚拟地址。
7. 最后根据线性地址算出实际的物理地址。 

>引用自[寻访x86处理器“实模式”和“保护模式”的前世今生](http://blog.chinaunix.net/uid-23069658-id-3569341.html?page=2)


>段描述符分为数据段描述符、指令段描述符和系统段描述符三种。
在很多描述符表中，最重要的就是全局描述符表（Global Descriptor Table，GDT），它为整个软硬件系统服务。
[hurlex <六> 添加全局段描述符表](http://wiki.0xffffff.org/posts/hurlex-6.html#fn:2)




